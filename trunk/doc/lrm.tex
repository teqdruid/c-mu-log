%  Written for Columbia COMS4112, fall 2008
\documentclass[onecolumn,titlepage]{article}
\usepackage[pdftex]{graphicx}
\usepackage{fullpage}
\usepackage{moreverb}
\usepackage{multicol}

\usepackage[left=2cm,top=2cm,bottom=2cm,right=2cm]{geometry}

\def\sourcetabsize{4}
\newenvironment{sourcestyle}{\begin{scriptsize}}{\end{scriptsize}}
\def\sourceinput#1{\par\begin{sourcestyle}\verbatimtabinput[\sourcetabsize]{#1}\end{sourcestyle}\par}

\usepackage{float}
 
\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Program}


\begin{document}
\title{C$\mu$LOG Reference Manual\\\small{An Entity Interaction Simulation Language}}
\author{John Demme (jdd2127)\\Nishant Shah (nrs2127)\\Devesh Dedhia (ddd2121)\\Cheng Cheng (cc2999)
\\ \\Columbia University}

\maketitle

\section{Overview}

\section{Purpose}
The language proposed here is ideal for entity interaction and simulation for a 
number of important reasons:
\begin{itemize}
\item Generic- games are defined completely by the environment application.

\item Composable- individual behaviors can be written simply and easily, then combined
  to obtain high-level actions and reasoning.

\item Declarative- programmers can specify what they want entities to do rather than how

\item Controlled Communication- data in the system is frequently made up of nearly-atomic bits of data
  many of which can be used both on their own and composed as complex data.  This means that subsets
  and smaller pieces of data can be communicated between entities without loosing meaning.

\item High-level libraries- due to the flexibility of the language, high-level
  algorithms--such as path-finding--can be easily implemented in libraries, allowing
  further, domain-specific intelligence to be written in the programs.
\end{itemize}

\section{Facts}
-What are facts
   Define a true relationship
   Another way to look at it: a terminal in a solution search.
-How do they look
   foo(4, symA);
     relationship: foo - 4 - symA  is true
   foo(4, symA, _);
     relationsihp: foo - 4 - symA - (anything)  is true
-Example: wall(4,5);

\section{Rules}
-What are rules
   Define something which is conditionally true
   Another way to look at it: a node in the search tree
-How do they look?
   foo(4) { bar(5); }
    foo(4) is true if bar(5) is true, but not iff
   foo(4) { bar(6); }
   Together, are equivalent to 
   foo(4) {OR: bar(5); bar(6); }

\section{Variables}
-Represent a value to be solved for
-Special variable: ? (the anonymous variable)
-syntax: \$[a-zA-Z][a-zA-Z0-9_]*
-Dollar sign, followed by the variable name.  The name must start with a letter, and is composed of letters, numbers, and underscore (_)
-Examples: \$X, \$foo, \$foo9...

\section{Blocks}
-Contain statements terminated by ;
-Can begin with OR: or AND: to identify reduction method
-Can contain sub-blocks, treated as statements
-Examples:
  { 
    foo;
    bar;
  }
 True if foo and bar are true.
  {OR:
    foo;
    bar;
  }
 True if foo or bar are true.

\section{Statements}
-Comparisons:
   1 < \$X;
   4 < \$Y <= 9;
-Evals:
 foo(\$X, \$Y, 7);
-Blocks

\section{Types}
-Integers
-Strings (atomic)
-Arrays
-Symbols
-Entity

\section{Rule Evaluation}

\section{Arrays}
- Delimited by []
- Items separated by commas
- Only occur as parameters for rules, facts, and evals
- Functional-style linked lists
- Matching similar to functional list matching

\section{Program Modification}
-@learn
-@forget

\section{Interaction- The Dot Operator}
-If a variable represents another entity (program), one can attempt to
  access another entity's rules and facts
  

\section{Directives}
-@attach
-@print
-Potentially other things using @something syntax

\section{Tokens}

\section{Example Code}
Several examples are now given.  They are not complete, and only intended
to give a gist of the language's syntax and semantics.

The environ1.ul program defines a 15x15 grid as well as several wall locutions.
The simulator doesn't know anything about a ``wall'' or a ``goal'', but gets
symbols for each grid point by solving the ``object'' rule.  The environment
interacts with the simulator primarily via the object rule.  The ``repr'' rule
is also used to tell the simulator what file should be associated with each
symbol.  This file could be an image (to display on the grid) or an agent program
to run, starting in that grid.

The agent1.ul program is a pretty simple program which attempts to reach the ``goalObject''
without running into anything else. To do this, it uses very simple graph-search 
algorithms to find a valid path to the goalObject, or--alternatively--a grid square
which it has not been to yet.  This sort of searching algorithm is very simple in
C$\mu$LOG due to it's logical nature.  Indeed, it depends on the simple search 
which is used internally to solve programs.  The agent also attempts to communicate it's 
knowledge of the environment to any other agents it encounters.


\begin{program}
\begin{multicols}{2}
\sourceinput{samples/environ1.ul}
\end{multicols}
\caption{A sample C$\mu$LOG environment programming}
\end{program}

\begin{program}
\begin{multicols}{2}
\sourceinput{samples/agent1.ul}
\end{multicols}
\caption{A sample C$\mu$LOG agent}
\end{program}

\end{document}
